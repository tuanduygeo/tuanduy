import streamlit as st
import os
import pandas as pd
import streamlit.components.v1 as components
import math
from datetime import date, timedelta, datetime
import swisseph as swe
import pytz
import matplotlib.pyplot as plt
import random
import numpy as np
import requests

st.set_page_config(layout="wide")
st.markdown("""
### 1.PHONG TH·ª¶Y ƒê·ªäA L√ù ‚Äì B·∫¢N ƒê·ªí ƒê·ªäA M·∫†CH
""")

# Kh·ªüi t·∫°o session state
if "selected_idx" not in st.session_state:
    st.session_state.selected_idx = None
# Th∆∞ m·ª•c ch·ª©a HTML
html_dir = "dulieu"
html_files = sorted([f for f in os.listdir(html_dir) if f.endswith(".html")])
df = pd.DataFrame({"T√™n c√¥ng tr√¨nh": html_files})

# Ph√¢n trang
per_page = 10
total_pages = math.ceil(len(df) / per_page)
page = st.number_input(f"üìÑ Trang (1‚Äì{total_pages}):", min_value=1, max_value=total_pages, value=1, step=1)

start_idx = (page - 1) * per_page
end_idx = start_idx + per_page
df_page = df.iloc[start_idx:end_idx]

# Hi·ªÉn th·ªã danh s√°ch t·ª´ng trang
for i, (_, row) in enumerate(df_page.iterrows()):
    idx = start_idx + i
    col1, col2 = st.columns([5, 1])
    with col1:
        st.markdown(f"üî∏ **{row['T√™n c√¥ng tr√¨nh']}**")
    with col2:
        if st.button("Xem", key=row['T√™n c√¥ng tr√¨nh']):
            st.session_state.selected_idx = idx

# Hi·ªÉn th·ªã b·∫£n ƒë·ªì
if "selected_idx" not in st.session_state:
    st.session_state.selected_idx = None

# N·∫øu c√≥ danh s√°ch HTML
if html_files:
    df = pd.DataFrame({"T√™n c√¥ng tr√¨nh": html_files})

    # N·∫øu ch∆∞a ch·ªçn g√¨ ‚Üí hi·ªÉn th·ªã m·∫∑c ƒë·ªãnh b·∫£n ƒë·ªì ƒë·∫ßu ti√™n
    if st.session_state.selected_idx is None:
        default_html = random.choice(html_files)
        html_path = os.path.join(html_dir, default_html)
        st.subheader(f"üìç B·∫£n ƒë·ªì m·∫∑c ƒë·ªãnh: {default_html}")
        with open(html_path, 'r', encoding='utf-8') as f:
            html_content = f.read()
            components.html(html_content, height=1100, scrolling=True)

    # N·∫øu ƒë√£ ch·ªçn ‚Üí hi·ªÉn th·ªã b·∫£n ƒë·ªì c√≥ n√∫t ti·∫øn l√πi
    else:
        selected_html = df.iloc[st.session_state.selected_idx]['T√™n c√¥ng tr√¨nh']

        col1, _, col3 = st.columns([1, 6, 1])
        with col1:
            if st.button("‚¨ÖÔ∏è L√πi") and st.session_state.selected_idx > 0:
                st.session_state.selected_idx -= 1
                st.rerun()
        with col3:
            if st.button("Ti·∫øn ‚û°Ô∏è") and st.session_state.selected_idx < len(df) - 1:
                st.session_state.selected_idx += 1
                st.rerun()

        st.markdown("---")
        st.subheader(f"üó∫Ô∏è B·∫£n ƒë·ªì: {selected_html}")
        html_path = os.path.join(html_dir, selected_html)
        with open(html_path, 'r', encoding='utf-8') as f:
            html_content = f.read()
            components.html(html_content, height=1100, scrolling=True)
else:
    st.warning("Kh√¥ng t√¨m th·∫•y file HTML n√†o trong th∆∞ m·ª•c 'dulieu/'")

st.markdown("""
### üìå H∆∞·ªõng d·∫´n
- Danh s√°ch 200 c√¥ng tr√¨nh ƒë∆∞·ª£c th∆∞·ªùng xuy√™n thay ƒë·ªïi/ 4900 c√¥ng tr√¨nh t√¢m linh ƒë∆∞·ª£c t√°c gi·∫£ thu th·∫≠p t·∫°i Vi·ªát Nam.
- C√¥ng ngh·ªá: ·ª®ng d·ª•ng c√¥ng ngh·ªá t·ª± ƒë·ªông h√≥a ƒë·ªãa kh√¥ng gian ƒë·ªÉ x√°c ƒë·ªãnh vector c√°c h∆∞·ªõng ƒë·ªãa m·∫°ch t·ª± ƒë·ªông t·∫°i c√°c c√¥ng tr√¨nh.
- Phi√™n b·∫£n: V1.0 phi√™n b·∫£n web ∆∞u ti√™n s·ªë li·ªáu nh·∫π, vector h∆∞·ªõng m·∫°ch mang t√≠nh tham kh·∫£o- kh√¥ng ch√≠nh x√°c tuy·ªát ƒë·ªëi.
- C√°ch d√πng: C√°c b·∫°n ch·ªçn trang ‚Üí B·∫•m `Xem` ‚Üí B·∫£n ƒë·ªì s·∫Ω hi·ªÉn th·ªã b√™n d∆∞·ªõi.
""")

st.markdown("""
### 2.Chi√™m tinh ·∫§n ƒê·ªô""")

# ==== Setup ====
swe.set_ephe_path("ephe")
swe.set_sid_mode(swe.SIDM_LAHIRI)
vn_tz = pytz.timezone("Asia/Ho_Chi_Minh")
# L·∫•y gi·ªù hi·ªán t·∫°i ·ªü m√∫i gi·ªù Vi·ªát Nam
now_local = datetime.now(vn_tz)

# Chuy·ªÉn ƒë·ªïi gi·ªù hi·ªán t·∫°i v·ªÅ UTC
now_utc = now_local.astimezone(pytz.utc)

jd = swe.julday(now_utc.year, now_utc.month, now_utc.day,
                now_utc.hour + now_utc.minute / 60 + now_utc.second / 3600)

st.markdown(f"**üïí Gi·ªù hi·ªán t·∫°i (VN)**: {now_local.strftime('%Y-%m-%d %H:%M:%S')}")
# --- Ch·ªçn th·ªùi gian v√† t·ªça ƒë·ªô ---
col1, col2 = st.columns([1, 1])

# Kh·ªüi t·∫°o session_state n·∫øu ch∆∞a c√≥ (ch·∫°y 1 l·∫ßn duy nh·∫•t)
if "selected_date" not in st.session_state:
    st.session_state.selected_date = datetime.now().date()
if "selected_time" not in st.session_state:
    st.session_state.selected_time = datetime.now().time()

with col1:
    # Giao di·ªán ch·ªçn ng√†y v√† gi·ªù
    st.session_state.selected_date = st.date_input("üìÖ Ch·ªçn ng√†y", value=st.session_state.selected_date,min_value=date(1900, 1, 1),
        max_value=date(2100, 12, 31))
    st.session_state.selected_time = st.time_input("‚è∞ Ch·ªçn gi·ªù", value=st.session_state.selected_time)

    # G·ªôp l·∫°i th√†nh datetime ho√†n ch·ªânh
    selected_datetime = datetime.combine(
        st.session_state.selected_date,
        st.session_state.selected_time
    )

with col2:
    # Giao di·ªán nh·∫≠p t·ªça ƒë·ªô
    latitude = st.number_input("üåê Vƒ© ƒë·ªô", min_value=-90.0, max_value=90.0, value=21.0, step=0.1)
    longitude = st.number_input("üåê Kinh ƒë·ªô", min_value=-180.0, max_value=180.0, value=105.8, step=0.1)
# Button to calculate
if st.button("T√≠nh To√°n"):
    if selected_datetime.tzinfo is None:
        selected_datetime_vn = vn_tz.localize(selected_datetime)
    else:
        selected_datetime_vn = selected_datetime.astimezone(vn_tz)

    selected_utc = selected_datetime_vn.astimezone(pytz.utc)

    jd = swe.julday(selected_utc.year, selected_utc.month, selected_utc.day,
                    selected_utc.hour + selected_utc.minute / 60 + selected_utc.second / 3600)

    st.markdown(f"**Vƒ© ƒë·ªô**: {latitude}¬∞ **Kinh ƒë·ªô**: {longitude}¬∞ ")
    st.markdown(f"**NƒÉm**: {selected_utc.year} **Th√°ng**: {selected_utc.month} **Ng√†y**: {selected_utc.day} **Gi·ªù**: {selected_utc.hour+7}")


rashis = ["B·∫°ch D∆∞∆°ng", "Kim Ng∆∞u", "Song T·ª≠", "C·ª± Gi·∫£i", "S∆∞ T·ª≠", "X·ª≠ N·ªØ", "Thi√™n B√¨nh", "B·ªç C·∫°p",
          "Nh√¢n M√£", "Ma K·∫øt", "B·∫£o B√¨nh", "Song Ng∆∞"]
# Danh s√°ch Nakshatra
nakshatras = [
    "Ashwini", "Bharani", "Krittika", "Rohini", "Mrigashirsha", "Ardra", "Punarvasu", "Pushya", "Ashlesha",
    "Magha", "Purva Phalguni", "Uttara Phalguni", "Hasta", "Chitra", "Swati", "Vishakha", "Anuradha",
    "Jyeshtha", "Mula", "Purva Ashadha", "Uttara Ashadha", "Shravana", "Dhanishta", "Shatabhisha",
    "Purva Bhadrapada", "Uttara Bhadrapada", "Revati"
]
planets = {
    'Sun': swe.SUN, 'Moon': swe.MOON, 'Mars': swe.MARS, 'Mercury': swe.MERCURY,
    'Jupiter': swe.JUPITER, 'Venus': swe.VENUS, 'Saturn': swe.SATURN, 'Rahu': swe.MEAN_NODE
}
dignities = {
    "Sun": {"v∆∞·ª£ng": "S∆∞ T·ª≠", "t∆∞·ªõng": "B·∫°ch D∆∞∆°ng", "t√π": "Thi√™n B√¨nh", "t·ª≠": "B·∫£o B√¨nh","b·∫°n b√®": {"C·ª± Gi·∫£i", "Song Ng∆∞","Nh√¢n m√£", "B·ªç C·∫°p" },"ƒë·ªãch th·ªß": {"Kim Ng∆∞u", "Song T·ª≠","X·ª≠ N·ªØ","Ma K·∫øt"  }},
    "Moon": {"v∆∞·ª£ng": "C·ª± Gi·∫£i", "t∆∞·ªõng": "Kim Ng∆∞u", "t√π": "B·ªç C·∫°p", "t·ª≠": "Ma K·∫øt","b·∫°n b√®": {"B·∫°ch D∆∞∆°ng","S∆∞ T·ª≠", "Song Ng∆∞","Nh√¢n m√£" },"ƒë·ªãch th·ªß": {"Thi√™n B√¨nh", "Song T·ª≠","X·ª≠ N·ªØ","B·∫£o B√¨nh"  }},
    "Mars": { "v∆∞·ª£ng": {"B·∫°ch D∆∞∆°ng","B·ªç C·∫°p"}, "t∆∞·ªõng": "Ma K·∫øt", "t√π": "C·ª± Gi·∫£i", "t·ª≠": {"Kim Ng∆∞u","Thi√™n B√¨nh"},"b·∫°n b√®": {"S∆∞ T·ª≠", "Song Ng∆∞","Nh√¢n m√£" },"ƒë·ªãch th·ªß": {"Song T·ª≠","X·ª≠ N·ªØ","B·∫£o B√¨nh"}},
    "Mercury": {"v∆∞·ª£ng": {"Song T·ª≠","X·ª≠ N·ªØ" }, "t∆∞·ªõng": "X·ª≠ N·ªØ", "t√π": "Song Ng∆∞", "t·ª≠": "Nh√¢n M√£","b·∫°n b√®": {"Kim Ng∆∞u", "B·∫£o B√¨nh","Thi√™n B√¨nh" },"ƒë·ªãch th·ªß": {"B·∫°ch D∆∞∆°ng", "B·ªç C·∫°p","C·ª± Gi·∫£i","S∆∞ T·ª≠"}},
    "Jupiter": {"v∆∞·ª£ng": {"Nh√¢n M√£","Song Ng∆∞" }, "t∆∞·ªõng": "C·ª± Gi·∫£i", "t√π": "Ma K·∫øt", "t·ª≠": {"Song T·ª≠","X·ª≠ N·ªØ"},"b·∫°n b√®": {"S∆∞ T·ª≠", "B·∫°ch D∆∞∆°ng","Nh√¢n m√£" },"ƒë·ªãch th·ªß": {"Kim Ng∆∞u", "Thi√™n B√¨nh","B·∫£o B√¨nh"}},
    "Venus": {"v∆∞·ª£ng": {"Kim Ng∆∞u","Thi√™n B√¨nh" }, "t∆∞·ªõng": "Song Ng∆∞", "t√π": "X·ª≠ N·ªØ", "t·ª≠": {"B·ªç C·∫°p","B·∫°ch D∆∞∆°ng"},"b·∫°n b√®": {"Ma K·∫øt","X·ª≠ N·ªØ","B·∫£o B√¨nh","Song T·ª≠" },"ƒë·ªãch th·ªß": {"B·∫°ch D∆∞∆°ng", "B·ªç C·∫°p","C·ª± Gi·∫£i","S∆∞ T·ª≠"}},
    "Saturn": {"v∆∞·ª£ng": {"Ma K·∫øt","B·∫£o B√¨nh" }, "t∆∞·ªõng": "Thi√™n B√¨nh", "t√π": "B·∫°ch D∆∞∆°ng", "t·ª≠": {"C·ª± Gi·∫£i","S∆∞ T·ª≠"},"b·∫°n b√®": {"Kim Ng∆∞u","Song T·ª≠","Thi√™n B√¨nh" },"ƒë·ªãch th·ªß": {"Nh√¢n M√£", "B·ªç C·∫°p","Song Ng∆∞"}},
              }
dasha_sequence = ["Ketu", "Venus", "Sun", "Moon", "Mars", "Rahu", "Jupiter", "Saturn", "Mercury"]
dasha_years = {"Ketu": 7, "Venus": 20, "Sun": 6, "Moon": 10, "Mars": 7, "Rahu": 18, "Jupiter": 16, "Saturn": 19, "Mercury": 17}
rashi_to_number = {
    "B·∫°ch D∆∞∆°ng": 1, "Kim Ng∆∞u": 2, "Song T·ª≠": 3, "C·ª± Gi·∫£i": 4,
    "S∆∞ T·ª≠": 5, "X·ª≠ N·ªØ": 6, "Thi√™n B√¨nh": 7, "B·ªç C·∫°p": 8,
    "Nh√¢n M√£": 9, "Ma K·∫øt": 10, "B·∫£o B√¨nh": 11, "Song Ng∆∞": 12
}
nakshatra_to_gana = {
    "Ashwini": "Thi√™n th·∫ßn", "Bharani": "Nh√¢n", "Krittika": "Qu·ª∑ th·∫ßn",
    "Rohini": "Nh√¢n", "Mrigashirsha": "Thi√™n th·∫ßn", "Ardra": "Qu·ª∑ th·∫ßn",
    "Punarvasu": "Thi√™n th·∫ßn", "Pushya": "Thi√™n th·∫ßn", "Ashlesha": "Qu·ª∑ th·∫ßn",
    "Magha": "Qu·ª∑ th·∫ßn", "Purva Phalguni": "Nh√¢n", "Uttara Phalguni": "Nh√¢n",
    "Hasta": "Thi√™n th·∫ßn", "Chitra": "Qu·ª∑ th·∫ßn", "Swati": "Thi√™n th·∫ßn", "Vishakha": "Qu·ª∑ th·∫ßn",
    "Anuradha": "Thi√™n th·∫ßn", "Jyeshtha": "Qu·ª∑ th·∫ßn", "Mula": "Qu·ª∑ th·∫ßn",
    "Purva Ashadha": "Nh√¢n", "Uttara Ashadha": "Nh√¢n", "Shravana": "Thi√™n th·∫ßn",
    "Dhanishta": "Qu·ª∑ th·∫ßn", "Shatabhisha": "Qu·ª∑ th·∫ßn", "Purva Bhadrapada": "Nh√¢n",
    "Uttara Bhadrapada": "Nh√¢n", "Revati": "Thi√™n th·∫ßn"
}
# ==== H√†m ph·ª• ====
def get_rashi(degree):
    return rashis[int(degree // 30)]
def get_gana(nakshatra):
    return nakshatra_to_gana.get(nakshatra, "")
def get_dignity(planet, rashi):
    dign = dignities.get(planet, {})
    if rashi == dign.get("v∆∞·ª£ng"):
        return "v∆∞·ª£ng"
    elif rashi == dign.get("t∆∞·ªõng"):
        return "t∆∞·ªõng"
    elif rashi == dign.get("t√π"):
        return "t√π"
    elif rashi == dign.get("t·ª≠"):
        return "t·ª≠"
     # Check for "b·∫°n b√®" and "ƒë·ªãch th·ªß" (they are sets)
    elif rashi in dign.get("b·∫°n b√®", set()):
        return "b·∫°n b√®"
    elif rashi in dign.get("ƒë·ªãch th·ªß", set()):
        return "ƒë·ªãch th·ªß"
    return ""
def get_nakshatra(degree):
    return nakshatras[int(degree // (360 / 27))]

def is_combust(planet_name, planet_lon, sun_lon, retrograde=False):
    if planet_name in ["Sun", "Rahu", "Ketu"]:
        return False
    diff = abs((planet_lon - sun_lon + 180) % 360 - 180)
    
    combust_limits = {
        "Moon": 8,
        "Mercury": 4 ,
        "Venus": 6,
        "Mars": 8,
        "Jupiter": 8,
        "Saturn": 8
    }
    limit = combust_limits.get(planet_name, 0)
    return diff < limit
def get_pada(degree):
    deg_in_nak = degree % (360 / 27)
    return int(deg_in_nak // (13.3333 / 4)) + 1


def compute_ketu(rahu_deg):
    return (rahu_deg + 180.0) % 360.0

def deg_to_dms(degree):
    d = int(degree)
    m = int((degree - d) * 60)
    s = int(((degree - d) * 60 - m) * 60)
    return f"{d}¬∞{m:02d}'{s:02d}\""


def get_house_for_planet(lon, house_cusps):
    for i in range(12):
        start = house_cusps[i]
        end = house_cusps[i + 1]
        if end < start: end += 360
        lon_mod = lon if lon >= start else lon + 360
        if start <= lon_mod < end:
            return i + 1
    return None
def is_retrograde(code, jd_current, jd_previous):
    # T√≠nh to√°n v·ªã tr√≠ h√†nh tinh t·∫°i th·ªùi ƒëi·ªÉm hi·ªán t·∫°i
    res_current, _ = swe.calc_ut(jd_current, code)
    lon_deg_current = res_current[0]
    
    # T√≠nh to√°n v·ªã tr√≠ h√†nh tinh t·∫°i th·ªùi ƒëi·ªÉm tr∆∞·ªõc ƒë√≥
    res_previous, _ = swe.calc_ut(jd_previous, code)
    lon_deg_previous = res_previous[0]
    
    # Ki·ªÉm tra xem v·ªã tr√≠ c√≥ thay ƒë·ªïi h∆∞·ªõng kh√¥ng
    # N·∫øu s·ª± thay ƒë·ªïi gi·ªØa hai ng√†y c√≥ d·∫•u hi·ªáu quay ng∆∞·ª£c, h√†nh tinh ƒëang ngh·ªãch h√†nh
    if lon_deg_current < lon_deg_previous:
        return True
    return False


houses,ascmc = swe.houses_ex(jd, latitude, longitude, b'W', swe.FLG_SIDEREAL)
asc = houses[0]
ast=ascmc[0]
asc_rashi = get_rashi(ast)
asc_pada = get_pada(ast)
asc_nak = get_nakshatra(ast)
asc_degree_dms = deg_to_dms(ast % 30)
asc_gana = get_gana(asc_nak)
equal_house_cusps = [(asc + i * 30) % 360 for i in range(12)] + [(asc + 360) % 360]
# T√≠nh to√°n c√°c h√†nh tinh
planet_data = []


# T√≠nh to√°n ng√†y tr∆∞·ªõc ƒë√≥ (1 ng√†y)
jd_previous = jd - 1  # Gi·∫£m 1 ng√†y ƒë·ªÉ l·∫•y ng√†y tr∆∞·ªõc ƒë√≥

planet_data.append({
    "H√†nh tinh": "Asc",
    "V·ªã tr√≠": asc_degree_dms,
    "Cung": asc_rashi,
    "T√∫": asc_nak,
    "Pada": asc_pada,
    "Gana": asc_gana,
    "Nh√†": 1,
    "T√≠nh ch·∫•t": "",
    "Ngh·ªãch h√†nh": ""
})

for name, code in planets.items():
    # T√≠nh ƒë·ªô c·ªßa h√†nh tinh ·ªü hi·ªán t·∫°i v√† tr∆∞·ªõc ƒë√≥
    lon_deg = swe.calc(jd, code, swe.FLG_SIDEREAL)[0][0]
    sun_lon = swe.calc(jd, swe.SUN, swe.FLG_SIDEREAL)[0][0]
    # Ki·ªÉm tra ngh·ªãch h√†nh v·ªõi hai ng√†y
    retrograde_status = "R" if is_retrograde(code, jd, jd_previous) else ""
    is_c = is_combust(name, lon_deg, sun_lon, retrograde=(retrograde_status == "R"))
    status = retrograde_status
    if is_c:
        status += " C"
    # Th√™m th√¥ng tin h√†nh tinh v√†o danh s√°ch planet_data
    planet_data.append({
        "H√†nh tinh": name,
        "V·ªã tr√≠": deg_to_dms(lon_deg % 30),
        "Cung": get_rashi(lon_deg),
        "T√∫": get_nakshatra(lon_deg),
        "Pada": get_pada(lon_deg),
        "Gana": get_gana(get_nakshatra(lon_deg)),
        "Nh√†": get_house_for_planet(lon_deg, equal_house_cusps),
        "T√≠nh ch·∫•t": get_dignity(name, get_rashi(lon_deg)),
        "Ngh·ªãch h√†nh": status,
    })
# T√¨m Rahu trong planet_data
rahu_deg = None
for planet in planet_data:
    if planet["H√†nh tinh"] == "Rahu":
        rahu_deg = swe.calc(jd, swe.MEAN_NODE, swe.FLG_SIDEREAL)[0][0]
        break

# N·∫øu Rahu c√≥ gi√° tr·ªã, t√≠nh to√°n Ketu
if rahu_deg is not None:
    ketu_deg = (rahu_deg + 180) % 360  # Ketu l√† ƒë·ªëi di·ªán c·ªßa Rahu

    # T√≠nh to√°n c√°c th√¥ng s·ªë c·ªßa Ketu
    ketu_rashi = get_rashi(ketu_deg)
    ketu_nak = get_nakshatra(ketu_deg)
    ketu_pada = get_pada(ketu_deg)
    ketu_sign_deg = deg_to_dms(ketu_deg % 30)
    ketu_dignity = ""  # Ketu kh√¥ng c√≥ "t√≠nh ch·∫•t" (v∆∞·ª£ng, t∆∞·ªõng, t√π, t·ª≠)
    ketu_bhava = get_house_for_planet(ketu_deg, equal_house_cusps)

    # Th√™m Ketu v√†o planet_data
    planet_data.append({
        "H√†nh tinh": "Ketu",
        "V·ªã tr√≠": ketu_sign_deg,
        "Cung": ketu_rashi,
        "T√∫": ketu_nak,
        "Pada": ketu_pada,
        "Gana": get_gana(ketu_nak),
        "Nh√†": ketu_bhava,
        "T√≠nh ch·∫•t": ketu_dignity,
        "Ngh·ªãch h√†nh": "R",  
    })


# H√†m v·∫Ω bi·ªÉu ƒë·ªì
def draw_chart(planet_data):
    fig, ax = plt.subplots(figsize=(4,4))
    ax.set_xlim(0, 100)
    ax.set_ylim(0, 100)
    ax.axis("off")

    # Khung ngo√†i
    ax.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], 'k', linewidth=2)

    # C√°c ƒë∆∞·ªùng ch√©o
    ax.plot([0, 100], [0, 100], 'k', linewidth=1)
    ax.plot([0, 100], [100, 0], 'k', linewidth=1)

    # ƒê∆∞·ªùng t·ª´ gi·ªØa c·∫°nh ƒë·∫øn trung t√¢m
    ax.plot([0, 50], [50, 100], 'k', linewidth=1)
    ax.plot([50, 100], [100, 50], 'k', linewidth=1)
    ax.plot([100, 50], [50, 0], 'k', linewidth=1)
    ax.plot([50, 0], [0, 50], 'k', linewidth=1)

    # H√¨nh thoi trung t√¢m
    ax.plot([0, 50, 100, 50, 0], [50, 100, 50, 0, 50], 'k', linewidth=1)
    # T·ªça ƒë·ªô t∆∞∆°ng ƒë·ªëi cho t·ª´ng nh√† (x, y)
    house_coords = {
        1: (50, 80),
        2: (25, 95),
        3: (10, 80),
        4: (25, 45),
        5: (15, 25),
        6: (25, 5),
        7: (50, 20),
        8: (75, 5),
        9: (95, 25),
        10: (75, 45),
        11: (95, 80),
        12: (75, 95),
    }   
   
    # Gom nh√≥m c√°c h√†nh tinh theo nh√†
    house_planets = {i: [] for i in range(1, 13)}
    for planet in planet_data:
        house = planet["Nh√†"]
        name = planet["H√†nh tinh"]
        if house:
            house_planets[house].append(name)

    # V·∫Ω t√™n h√†nh tinh t·∫°i v·ªã tr√≠ t·ª´ng nh√†
    for house, (x, y) in house_coords.items():
        labels = []
        for p in planet_data:
            if p["Nh√†"] == house:
                name = p["H√†nh tinh"]
                sign = p["Cung"]
                deg_str = p["V·ªã tr√≠"].split("¬∞")[0] + "¬∞"
                # Ki·ªÉm tra v√† g√°n m≈©i t√™n t∆∞∆°ng ·ª©ng
                dignity = get_dignity(name, sign)
                if dignity == "v∆∞·ª£ng" or dignity == "t∆∞·ªõng" or dignity == "b·∫°n b√®":
                    arrow = " ‚Üë"
                elif dignity == "t√π" or dignity == "t·ª≠" or dignity == "ƒë·ªãch th·ªß":
                    arrow = " ‚Üì"
                else:
                    arrow = ""
                
                labels.append(f"{name} ({sign} {deg_str}){arrow}")
        names = "\n".join(labels)
        ax.text(x, y, names, ha='center', va='center', fontsize=5, color='blue')
    for i, (x, y) in house_coords.items():
        cusp_degree = equal_house_cusps[i - 1]
        rashi_name = get_rashi(cusp_degree)
        rashi_number = rashi_to_number[rashi_name]
        ax.text(x-2, y + 3, str(rashi_number), fontsize=5, color='red',weight='bold')
    return fig  
fig = draw_chart(planet_data)
st.pyplot(fig, use_container_width=False)

df_planets = pd.DataFrame(planet_data)



rashi_rulers = {
    "B·∫°ch D∆∞∆°ng": "Mars", "Kim Ng∆∞u": "Venus", "Song T·ª≠": "Mercury", "C·ª± Gi·∫£i": "Moon",
    "S∆∞ T·ª≠": "Sun", "X·ª≠ N·ªØ": "Mercury", "Thi√™n B√¨nh": "Venus", "B·ªç C·∫°p": "Mars",
    "Nh√¢n M√£": "Jupiter", "Ma K·∫øt": "Saturn", "B·∫£o B√¨nh": "Saturn", "Song Ng∆∞": "Jupiter"
}

house_rulers = {
    i + 1: rashi_rulers[get_rashi(cusp)]
    for i, cusp in enumerate(equal_house_cusps[:12])
}

planet_to_ruled_houses = {}
for house, ruler in house_rulers.items():
    planet_to_ruled_houses.setdefault(ruler, []).append(house)

df_planets["Ch·ªß tinh c·ªßa nh√†"] = df_planets["H√†nh tinh"].apply(
    lambda p: planet_to_ruled_houses.get(p, [])
)
# === ƒê·ªãnh nghƒ©a quy t·∫Øc chi·∫øu Vedic ===
vedic_aspects = {
    "Saturn": [3, 7, 10],
    "Mars": [4, 7, 8],
    "Jupiter": [5, 7, 9],
    "Default": [7]
}

# B·∫£n ƒë·ªì h√†nh tinh -> nh√†
planet_house_map = {p["H√†nh tinh"]: p["Nh√†"] for p in planet_data}

# H√†m t√≠nh h√†nh tinh n√†o b·ªã chi·∫øu
def get_aspected_planets(planet_name, current_house):
    if current_house is None:
        return ""
    
    # L·∫•y danh s√°ch kho·∫£ng c√°ch c√°c nh√† b·ªã chi·∫øu
    aspect_offsets = vedic_aspects.get(planet_name, vedic_aspects["Default"])
    
    # T√≠nh c√°c nh√† b·ªã chi·∫øu
    aspected_houses = [((current_house + offset - 2) % 12) + 1 for offset in aspect_offsets]
    
    # T√¨m h√†nh tinh n·∫±m trong c√°c nh√† b·ªã chi·∫øu
    result = []
    for other_planet, house in planet_house_map.items():
        if other_planet != planet_name and house in aspected_houses:
            result.append(f"{other_planet} ( {house})")
    return ", ".join(result)

# Th√™m c·ªôt v√†o b·∫£ng
df_planets["Chi·∫øu h√†nh tinh"] = df_planets.apply(
    lambda row: get_aspected_planets(row["H√†nh tinh"], row["Nh√†"]), axis=1
)

st.markdown("### V·ªã tr√≠ h√†nh tinh")
st.dataframe(df_planets, use_container_width=True)
# === VIMSHOTTARI DASHA - GI·ªÆ NG√ÄY K·∫æT TH√öC, T√çNH NG√ÄY B·∫ÆT ƒê·∫¶U ===
st.markdown("### üïâÔ∏è B·∫£ng ƒê·∫°i V·∫≠n Vimshottari ")

# B·∫£ng √°nh x·∫° Nakshatra ‚Üí Dasha Lord
nakshatra_to_dasha_lord = {
    "Ashwini": "Ketu", "Bharani": "Venus", "Krittika": "Sun",
    "Rohini": "Moon", "Mrigashirsha": "Mars", "Ardra": "Rahu",
    "Punarvasu": "Jupiter", "Pushya": "Saturn", "Ashlesha": "Mercury",
    "Magha": "Ketu", "Purva Phalguni": "Venus", "Uttara Phalguni": "Sun",
    "Hasta": "Moon", "Chitra": "Mars", "Swati": "Rahu",
    "Vishakha": "Jupiter", "Anuradha": "Saturn", "Jyeshtha": "Mercury",
    "Mula": "Ketu", "Purva Ashadha": "Venus", "Uttara Ashadha": "Sun",
    "Shravana": "Moon", "Dhanishta": "Mars", "Shatabhisha": "Rahu",
    "Purva Bhadrapada": "Jupiter", "Uttara Bhadrapada": "Saturn", "Revati": "Mercury"
}

# Dasha sequence v√† s·ªë nƒÉm
dasha_sequence = ["Ketu", "Venus", "Sun", "Moon", "Mars", "Rahu", "Jupiter", "Saturn", "Mercury"]
dasha_years = {"Ketu": 7, "Venus": 20, "Sun": 6, "Moon": 10, "Mars": 7,
               "Rahu": 18, "Jupiter": 16, "Saturn": 19, "Mercury": 17}

# T√≠nh v·ªã tr√≠ M·∫∑t TrƒÉng
moon_longitude = swe.calc(jd, swe.MOON, swe.FLG_SIDEREAL)[0][0]

# X√°c ƒë·ªãnh nakshatra
nakshatra_index = int((moon_longitude % 360) / 13.3333333333)
nakshatra_fraction = ((moon_longitude % 360) % 13.3333333333) / 13.3333333333
nakshatra_name = nakshatras[nakshatra_index]
dasha_lord = nakshatra_to_dasha_lord[nakshatra_name]

# S·ªë nƒÉm c√≤n l·∫°i trong Mahadasha hi·ªán t·∫°i
full_years = dasha_years[dasha_lord]
remain_years = (1 - nakshatra_fraction) * full_years

# ‚úÖ Gi·ªØ ng√†y k·∫øt th√∫c l√† hi·ªán t·∫°i, t√≠nh ng∆∞·ª£c ra ng√†y b·∫Øt ƒë·∫ßu
end_jd = jd + remain_years * 365.25
start_jd = end_jd - full_years * 365.25
curr_jd = start_jd

# T·∫°o b·∫£ng Mahadasha
dasha_list = []
idx = dasha_sequence.index(dasha_lord)
for i in range(9):
    lord = dasha_sequence[(idx + i) % 9]
    duration = dasha_years[lord]

    start = swe.revjul(curr_jd)
    end_jd = curr_jd + duration * 365.25
    end = swe.revjul(end_jd)

    dasha_list.append({
        "Dasha": lord,
        "B·∫Øt ƒë·∫ßu": f"{int(start[2]):02d}-{int(start[1]):02d}-{int(start[0])}",
        "K·∫øt th√∫c": f"{int(end[2]):02d}-{int(end[1]):02d}-{int(end[0])}",
        "S·ªë nƒÉm": round(duration, 2)
    })

    curr_jd = end_jd

# Hi·ªÉn th·ªã b·∫£ng Mahadasha
df_dasha = pd.DataFrame(dasha_list)
st.dataframe(df_dasha, use_container_width=True)


# H√†m t√≠nh Antardasha chu·∫©n
def compute_antardasha(mahadasha_lord, start_jd, duration_years):
    antardashas = []
    start_index = dasha_sequence.index(mahadasha_lord)
    jd_pointer = start_jd

    for i in range(9):
        sub_lord = dasha_sequence[(start_index + i) % 9]
        weight = dasha_years[sub_lord] / 120
        sub_duration = duration_years * weight
        end_jd = jd_pointer + sub_duration * 365.25

        start = swe.revjul(jd_pointer)
        end = swe.revjul(end_jd)

        antardashas.append({
            "Antardasha": f"{mahadasha_lord}/{sub_lord}",
            "B·∫Øt ƒë·∫ßu": f"{int(start[2]):02d}-{int(start[1]):02d}-{int(start[0])}",
            "K·∫øt th√∫c": f"{int(end[2]):02d}-{int(end[1]):02d}-{int(end[0])}",
            "S·ªë nƒÉm": round(sub_duration, 2)
        })
        jd_pointer = end_jd

    return pd.DataFrame(antardashas)

all_antardasha = []
for _, row in df_dasha.iterrows():
    m_lord = row["Dasha"]
    m_start = datetime.strptime(row["B·∫Øt ƒë·∫ßu"], "%d-%m-%Y")
    m_start_jd = swe.julday(m_start.year, m_start.month, m_start.day)
    m_years = row["S·ªë nƒÉm"]
    all_antardasha += compute_antardasha(m_lord, m_start_jd, m_years).to_dict("records")

df_all_antar = pd.DataFrame(all_antardasha)

if st.checkbox("üëÅÔ∏è Hi·ªán to√†n b·ªô Antardasha cho 9 Mahadasha"):
    
    st.dataframe(df_all_antar, use_container_width=True)

# Quy t·∫Øc ƒëi·ªÉm s·ªë theo nh√†

benefic_house_scores = {1:3  ,2:2  ,3:-2  ,4:2  ,5:3  ,6:-2  ,7:2  ,8:-3  ,9:3  ,10:2  ,11:2  ,12:-3 }
malefic_house_scores = {1:2  ,2:2  ,3:0  ,4:1  ,5:2  ,6:0  ,7:2  ,8:-3  ,9:2  ,10:2  ,11:3  ,12:-3 }
benefics = {"Jupiter", "Venus", "Moon","Mercury"}
malefics = {"Mars", "Saturn", "Rahu", "Ketu","Sun"}
def get_house_score(house, planet):
    if planet in benefics:
        return benefic_house_scores.get(house, 0)
    elif planet in malefics:
        return malefic_house_scores.get(house, 0)
    else:
        return 0  # Trung l·∫≠p ho·∫∑c kh√¥ng r√µ
# T√≠nh d·ªØ li·ªáu v·∫Ω bi·ªÉu ƒë·ªì
def build_life_chart(df_dasha, planet_data, birth_jd):
    life_years = []
    life_scores = []
    year_labels = []
    current_year = 0
    birth_offset = None

    for _, m_row in df_dasha.iterrows():
        m_lord = m_row["Dasha"]
        m_start = datetime.strptime(m_row["B·∫Øt ƒë·∫ßu"], "%d-%m-%Y")
        m_start_jd = swe.julday(m_start.year, m_start.month, m_start.day)
        m_duration = m_row["S·ªë nƒÉm"]

        if birth_offset is None and birth_jd >= m_start_jd:
            birth_offset = (birth_jd - m_start_jd) / 365.25

        # ƒêi·ªÉm t·ª´ v·ªã tr√≠ hi·ªán t·∫°i c·ªßa h√†nh tinh
        m_house = next((p["Nh√†"] for p in planet_data if p["H√†nh tinh"] == m_lord), 0)
        m_score = get_house_score(m_house, m_lord)
        m_dignity = next((p["T√≠nh ch·∫•t"] for p in planet_data if p["H√†nh tinh"] == m_lord), "")
        if m_dignity in ["v∆∞·ª£ng", "t∆∞·ªõng"]:
            m_score += 1
        elif m_dignity == "b·∫°n b√®":
            m_score += 0.5
        elif m_dignity == "ƒë·ªãch th·ªß":
            m_score -= 0.5
        elif m_dignity in ["t√π", "t·ª≠"]:
            m_score -= 1
        # ‚úÖ Th√™m ƒëi·ªÉm theo t√≠nh ch·∫•t "C√°t ‚Äì Hung" c·ªßa h√†nh tinh
        if m_lord in ["Jupiter", "Venus", "Moon"]:
            m_score += 0.7
        elif m_lord in ["Mars", "Saturn", "Rahu", "Ketu"]:
            m_score -= 0.7
        m_status = next((p["Ngh·ªãch h√†nh"] for p in planet_data if p["H√†nh tinh"] == m_lord), "")
        if "R" in m_status and "C" in m_status:
            m_score -= 0.5
        # ‚úÖ Th√™m ƒëi·ªÉm d·ª±a tr√™n c√°c nh√† h√†nh tinh ƒë√≥ l√†m ch·ªß
        ruled_houses = planet_to_ruled_houses.get(m_lord, [])
        rule_bonus = 0
        for rh in ruled_houses:
            if rh in [6, 8, 12]:
                rule_bonus -= 3.5
            elif rh in [1, 5, 9]:
                rule_bonus += 3.5
            elif rh in [2, 4, 7, 10,11]:
                rule_bonus += 1.5
        
        m_score += rule_bonus
        # G√°n nh√£n m·ª•c ti√™u d·ª±a theo nh√†
        purpose = ""
        if m_house in [2, 11]:
            purpose = " (t√†i ‚Üë)"
        elif m_house in [1]:
            purpose = " (m·ªánh ‚Üë)"
        elif m_house in [ 9]:
            purpose = " (ƒë·∫°o ‚Üë)"
        elif m_house in [5]:
            purpose = " (h·ªçc ‚Üë)"
        elif m_house in [10]:
            purpose = " (danh ‚Üë)"
        elif m_house == 7:
            purpose = " (Quan h·ªá ‚Üë)"
        elif m_house == 3:
            purpose = " (Th·ªã phi ‚Üì)"
        elif m_house in [6,8,12]:
            purpose = " (t√†i,m·ªánh ‚Üì)"
            
        antars = compute_antardasha(m_lord, m_start_jd, m_duration)
        for _, antar in antars.iterrows():
            a_lord = antar["Antardasha"].split("/")[-1]
            a_years = antar["S·ªë nƒÉm"]
            a_house = next((p["Nh√†"] for p in planet_data if p["H√†nh tinh"] == a_lord), 0)
            a_score = get_house_score(a_house, a_lord) 
            # ‚úÖ Th√™m ƒëi·ªÉm t·ª´ nh√† m√† antardasha l√†m ch·ªß
            ruled_houses_a = planet_to_ruled_houses.get(a_lord, [])
            rule_bonus_a = 0
            for rh in ruled_houses_a:
                if rh in [6, 8, 12]:
                    rule_bonus_a -= 1
                elif rh in [1, 5, 9]:
                    rule_bonus_a += 1
                elif rh in [2, 4, 7, 10,11]:
                    rule_bonus_a += 0.5
            a_score += rule_bonus_a
            
            a_status = next((p["Ngh·ªãch h√†nh"] for p in planet_data if p["H√†nh tinh"] == a_lord), "")
            if "R" in a_status and "C" in a_status:
                a_score -= 0.2
            # ‚úÖ Th√™m ƒëi·ªÉm theo dignity (t√≠nh ch·∫•t) c·ªßa Antardasha lord
            a_dignity = next((p["T√≠nh ch·∫•t"] for p in planet_data if p["H√†nh tinh"] == a_lord), "")
            if a_dignity in ["v∆∞·ª£ng", "t∆∞·ªõng"]:
                a_score += 0.5
            elif a_dignity == "b·∫°n b√®":
                a_score += 0.2
            elif a_dignity == "ƒë·ªãch th·ªß":
                a_score -= 0.2
            elif a_dignity in ["t√π", "t·ª≠"]:
                a_score -= 0.5
                # 4Ô∏è‚É£ ƒêi·ªÉm t·ª´ ph√¢n lo·∫°i C√°t/Hung tinh
            if a_lord in ["Jupiter", "Venus", "Moon"]:
                a_score += 0.2
            elif a_lord in ["Mars", "Saturn", "Rahu", "Ketu"]:
                a_score -= 0.2
            total_score = round(0.33 *a_score +  m_score, 2)

            life_years.append(current_year)
            life_scores.append(total_score)
            year_labels.append(m_lord + purpose)
            current_year += a_years

    birth_x = round(birth_offset, 2) if birth_offset else 0
    return pd.DataFrame({"NƒÉm": life_years, "ƒêi·ªÉm s·ªë": life_scores, "Mahadasha": year_labels}), birth_x

# S·ª≠ d·ª•ng d·ªØ li·ªáu df_dasha, planet_data v√† jd ng√†y sinh
chart_df, birth_x = build_life_chart(df_dasha, planet_data, jd)

# V·∫Ω bi·ªÉu ƒë·ªì zigzag v√† ƒë∆∞·ªùng cong m∆∞·ª£t
fig, ax = plt.subplots(figsize=(12, 4))

ax.plot(chart_df["NƒÉm"], chart_df["ƒêi·ªÉm s·ªë"], marker='o')
# ƒê∆∞·ªùng k·∫ª ngang t·∫°i 0 (tr·ª•c ƒëi·ªÉm)
ax.axhline(y=0, color='black', linestyle='-', linewidth=2)
# Ph·ªß v√πng t·ª´ nƒÉm 80 ƒë·∫øn 120 b·∫±ng l·ªõp m·ªù
ax.axvspan(0, 70, color='grey', alpha=0.2)
# ƒê√°nh d·∫•u th·ªùi ƒëi·ªÉm sinh
ax.axvline(x=birth_x, color='purple', linestyle=':', linewidth=2)
ax.text(birth_x, min(chart_df["ƒêi·ªÉm s·ªë"]) - 5, "Sinh", rotation=90, color='purple', ha='center', va='bottom')
ax.set_ylim(-11, 11)

# C√†i ƒë·∫∑t chi ti·∫øt cho tr·ª•c ho√†nh
ax.set_xticks(range(int(chart_df["NƒÉm"].min()), int(chart_df["NƒÉm"].max()) + 1, 5))  # Interval = 5 nƒÉm
shown_mahadashas = set()

for x, y, label in zip(chart_df["NƒÉm"], chart_df["ƒêi·ªÉm s·ªë"], chart_df["Mahadasha"]):
    if label not in shown_mahadashas:
        ax.text(x, y + 0.5, label, fontsize=8,  ha='left', va='bottom')
        shown_mahadashas.add(label)
ax.tick_params(axis='x')  # N·∫øu b·∫°n mu·ªën nghi√™ng c√°c nh√£n nƒÉm cho d·ªÖ ƒë·ªçc
ax.set_title("Bi·ªÉu ƒë·ªì ƒë·∫°i v·∫≠n (tham kh·∫£o)")

ax.set_xlabel("NƒÉm")
ax.set_ylabel("ƒêi·ªÉm s·ªë")
ax.grid(True)
ax.legend()
st.pyplot(fig)
filtered_df = chart_df[chart_df["NƒÉm"].between(0, 70)]
median_score = round(filtered_df["ƒêi·ªÉm s·ªë"].median(), 2)
st.subheader(f"**ƒêi·ªÉm(Thang t·ª´ -10 ƒë·∫øn 10):** `{median_score}`")

st.markdown("""
### 3.üåêBi·ªÉu ƒë·ªì c·ªông h∆∞·ªüng Schumann Tr√°i ƒê·∫•t tr·ª±c tuy·∫øn
Ngu·ªìn: [Tomsk, Russia ‚Äì Space Observing System]
""")
st.image("https://sosrff.tsu.ru/new/shm.jpg", caption="Schumann Resonance - Live", use_container_width=True)

st.markdown("""
### 4.üß≤ D·ªØ li·ªáu ƒë·ªãa t·ª´ tr·ª±c tuy·∫øn""")
start_date = (datetime.today() - timedelta(days=15)).strftime('%Y-%m-%d')
end_date = datetime.today().strftime('%Y-%m-%d')
iframe_url = f"https://imag-data.bgs.ac.uk/GIN_V1/GINForms2?" \
             f"observatoryIagaCode=PHU&publicationState=Best+available" \
             f"&dataStartDate={start_date}&dataDuration=30" \
             f"&samplesPerDay=minute&submitValue=View+%2F+Download&request=DataView"
# Hi·ªÉn th·ªã trong Streamlit
st.components.v1.iframe(iframe_url, height=1000,scrolling=True)

st.markdown("""
###  Ch·ªâ s·ªë Kp ‚Äì C·∫£nh b√°o B√£o T·ª´
""")

kp_url = "https://services.swpc.noaa.gov/json/planetary_k_index_1m.json"

def interpret_kp(kp):
    if kp <= 2:
        return "üü¢ R·∫•t an to√†n"
    elif kp == 3:
        return "üü¢ An to√†n"
    elif kp == 4:
        return "üü° Trung b√¨nh ‚Äì ch√∫ √Ω nh·∫π"
    elif kp == 5:
        return "üü† C·∫£nh b√°o nh·∫π ‚Äì B√£o t·ª´ c·∫•p G1"
    elif kp == 6:
        return "üî¥ C·∫£nh b√°o ‚Äì B√£o t·ª´ c·∫•p G2"
    elif kp == 7:
        return "üî¥ Nguy hi·ªÉm ‚Äì B√£o t·ª´ c·∫•p G3"
    elif kp == 8:
        return "üî¥ R·∫•t nguy hi·ªÉm ‚Äì G4"
    else:
        return "üö® C·ª±c k·ª≥ nguy hi·ªÉm ‚Äì G5"

try:
    kp_data = requests.get(kp_url).json()
    df_kp = pd.DataFrame(kp_data)

    if 'kp_index' in df_kp.columns and not df_kp.empty:
        df_kp['time_tag'] = pd.to_datetime(df_kp['time_tag'])
        df_kp.set_index('time_tag', inplace=True)

        latest_kp = df_kp['kp_index'].iloc[-1]
        st.metric("üåê Kp Index (hi·ªán t·∫°i)", f"{latest_kp}", delta=interpret_kp(latest_kp))

        # Hi·ªÉn th·ªã bi·ªÉu ƒë·ªì 3 ng√†y g·∫ßn nh·∫•t
        df_kp['date'] = df_kp.index.date
        last_3_days = sorted(df_kp['date'].unique())[-3:]
        df_plot = df_kp[df_kp['date'].isin(last_3_days)]
        st.line_chart(df_plot['kp_index'])

    else:
        st.warning("‚ö†Ô∏è Kh√¥ng t√¨m th·∫•y c·ªôt 'kp_index' trong d·ªØ li·ªáu.")
except Exception as e:
    st.error("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu Kp Index.")
    st.text(str(e))

st.markdown("""
### 5.M√î H√åNH L·∫†C TH∆Ø 3X3 V√Ä B·∫¨C CAO V√î T·∫¨N
""")

# Nh·∫≠p b·∫≠c c·ªßa ma ph∆∞∆°ng
n = st.number_input("Nh·∫≠p b·∫≠c l·∫ª n (>=3):", min_value=3, step=2, value=3)

def generate_magic_square_southeast(n):
    if n % 2 == 0:
        raise ValueError("Ch·ªâ h·ªó tr·ª£ ma ph∆∞∆°ng b·∫≠c l·∫ª.")

    square = np.zeros((n, n), dtype=int)
    
    # B·∫Øt ƒë·∫ßu t·ª´ v·ªã tr√≠ g·∫ßn t√¢m: (t√¢m h√†ng + 1, t√¢m c·ªôt)
    i, j = n // 2 + 1, n // 2

    for num in range(1, n * n + 1):
        square[i % n, j % n] = num
        
        # V·ªã tr√≠ k·∫ø ti·∫øp theo h∆∞·ªõng ƒê√¥ng Nam
        new_i, new_j = (i + 1) % n, (j + 1) % n

        if square[new_i, new_j] != 0:
            # N·∫øu b·ªã tr√πng, th√¨ nh·∫£y xu·ªëng th√™m 1 h√†ng
            i = (i + 2) % n
        else:
            i, j = new_i, new_j

    return square
# X√°c ƒë·ªãnh h√†ng v√† c·ªôt trung t√¢m
center_index = n // 2

# H√†m t√¥ m√†u c√°c √¥ thu·ªôc h√†ng/c·ªôt trung t√¢m
def highlight_center(row_or_col, axis='row'):
    return ['background-color: orange' if (i == center_index if axis == 'row' else row_or_col.name == center_index) else '' for i in range(len(row_or_col))]

# --- MAIN ---
try:
    square = generate_magic_square_southeast(n)
    df = pd.DataFrame(square)

   # üëâ Hi·ªÉn th·ªã b·∫£ng ma ph∆∞∆°ng v·ªõi t√¥ m√†u trung t√¢m
    st.markdown(f"#### Ma ph∆∞∆°ng {n}x{n}:") 
    styled_df = df.style.format("{:d}") \
        .apply(highlight_center, axis=1) \
        .apply(highlight_center, axis=0)
    st.dataframe(styled_df)

    # --- Ki·ªÉm tra t·ªïng ---
    
    row_sums = df.sum(axis=1)
    col_sums = df.sum(axis=0)
    diag1 = np.trace(square)
    diag2 = np.trace(np.fliplr(square))
    magic_const = n * (n ** 2 + 1) // 2

    st.markdown(f"- T·ªïng chu·∫©n (magic constant): **{magic_const}**")
    st.markdown(f"- T·ªïng h√†ng: **{row_sums.iloc[0]}**")
    st.markdown(f"- T·ªïng c·ªôt: **{col_sums.iloc[0]}**")
    st.markdown(f"- T·ªïng ƒë∆∞·ªùng ch√©o ch√≠nh: {diag1}")
    st.markdown(f"- T·ªïng ƒë∆∞·ªùng ch√©o ph·ª•: {diag2}")

    if (
        all(row_sums == magic_const)
        and all(col_sums == magic_const)
        and diag1 == magic_const
        and diag2 == magic_const
    ):
        st.success("üéâ ƒê√¢y l√† ma ph∆∞∆°ng chu·∫©n h·ª£p l·ªá!")
    else:
        st.warning("‚ö†Ô∏è Ma ph∆∞∆°ng n√†y KH√îNG h·ª£p l·ªá.")

    
    # --- B·∫¢NG MODULO 9 ---
    st.markdown("#### B·∫£ng ma ph∆∞∆°ng chia h·∫øt cho 9:")  
    df_mod9 = df % 9
    
    # √Åp d·ª•ng highlight cho c·∫£ h√†ng v√† c·ªôt trung t√¢m
    styled_mod9 = df_mod9.style.format("{:d}") \
        .apply(highlight_center, axis=1) \
        .apply(highlight_center, axis=0)
    
    st.dataframe(styled_mod9)
    tong_cot_dau = df_mod9.iloc[:, 0].sum()
    st.markdown(f"üßæ T·ªïng m·ªói c·ªôt: **{tong_cot_dau}**")

except Exception as e:
    st.error(f"L·ªói: {e}")

def fibonacci_mod(mod, length):
    seq = [0, 1]
    for _ in range(length - 2):
        seq.append((seq[-1] + seq[-2]) % mod)
    return seq

def plot_fibonacci_triple_circle(values_outer, values_middle, labels_inner):
    n_outer = len(values_outer)
    n_middle = len(values_middle)
    n_inner = len(labels_inner)

    theta_outer = -np.linspace(0, 2*np.pi, n_outer, endpoint=False)
    theta_middle = -np.linspace(0, 2*np.pi, n_middle, endpoint=False)
    theta_inner = -np.linspace(0, 2*np.pi, n_inner, endpoint=False)
    theta_lines = -np.linspace(0, 2*np.pi, 24, endpoint=False)

    fig, ax = plt.subplots(subplot_kw={'projection': 'polar'})
    ax.spines['polar'].set_visible(False)
    ax.set_theta_direction(-1)
    ax.set_theta_offset(np.pi / 2)
    
    # V·∫Ω c√°c ƒë∆∞·ªùng chia
    bold_indices = {2, 5, 8, 11, 14, 17, 20, 23}
    shift = np.deg2rad(7.5)
    for i, t in enumerate(theta_lines):
        linewidth = 2 if i in bold_indices else 1
        ax.plot([t + shift, t + shift], [0.75, 1.05], color='black', linewidth=linewidth)

    # V·∫Ω c√°c v√≤ng tr√≤n
    for r in [1.05, 0.95, 0.85, 0.75]:
        circle_theta = np.linspace(0, 2 * np.pi, 1000)
        ax.plot(-circle_theta, [r] * len(circle_theta), color='black', linewidth=1)

    # C√°c l·ªõp d·ªØ li·ªáu
    for t, num in zip(theta_outer, values_outer):
        ax.text(t, 0.9, str(num), ha='center', va='center', fontsize=8)
    for t, num in zip(theta_middle, values_middle):
        ax.text(t, 1.0, str(num), ha='center', va='center', fontsize=8, color='darkblue')
    for t, label in zip(theta_inner, labels_inner):
        ax.text(t, 0.8, label, ha='center', va='center', fontsize=8, color='darkred')

    ax.text(0, 0, '+', ha='center', va='center', fontsize=12, fontweight='bold')

    ax.set_yticklabels([])
    ax.set_xticklabels([])
    ax.grid(False)
    plt.title("Fibonacci mod 9 & mod 10 + 24 ph√¢n cung (T√Ω, Nh√¢m,...)", va='bottom')

    # ‚úÖ Hi·ªÉn th·ªã trong Streamlit
    st.pyplot(fig)

# D·ªØ li·ªáu
fib_mod9 = fibonacci_mod(9, 24)
fib_mod10 = fibonacci_mod(10, 60)
labels_24 = [
    'T√Ω', 'Nh√¢m', 'H·ª£i', 'C√†n', 'Tu·∫•t', 'T√¢n', 'D·∫≠u', 'Canh',
    'Th√¢n', 'Kh√¥n', 'M√πi', 'ƒêinh', 'Ng·ªç', 'B√≠nh', 'T·ªµ', 'T·ªën',
    'Th√¨n', '·∫§t', 'M√£o', 'Gi√°p', 'D·∫ßn', 'C·∫•n', 'S·ª≠u', 'Qu√Ω'
]

# Streamlit layout
st.set_page_config(layout="wide")
st.title("üîÑ Bi·ªÉu ƒë·ªì v√≤ng tr√≤n Fibonacci mod 9 + mod 10")
plot_fibonacci_triple_circle(fib_mod9, fib_mod10, labels_24)


st.markdown("""
### T√°c gi·∫£ Nguy·ªÖn Duy Tu·∫•n ‚Äì v·ªõi m·ª•c ƒë√≠ch ph·ª•ng s·ª± t√¢m linh v√† c·ªông ƒë·ªìng.SƒêT&ZALO: 0377442597.DONATE: nguyenduytuan techcombank 19033167089018
""")
